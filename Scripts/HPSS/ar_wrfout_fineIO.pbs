#!/bin/bash
#MOAB/Torque archiving script for SciNet HPSS

## queue/PBS settings
# 72h is maximum for long queue, 1h for short
#PBS -l walltime=03:00:00
# merge standard error and output stream
#PBS -j oe
#PBS -o $PBS_JOBNAME.$PBS_JOBID.out
##PBS -e $PBS_JOBNAME.$PBS_JOBID.err
# send email if abort (nbae)
#PBS -M aerler@atmosp.physics.utoronto.ca
#PBS -m ae
# job name
#PBS -N ar_test
## submit to queue (NB: this has to be the last PBS line!)
#PBS -q archive

#set -o pipefail # through error (in exit code) if pipe fails
trap "echo 'Job script not completed';exit 129" TERM INT
# Note that your initial directory in HPSS will be /archive/$(id -gn)/$(whoami)/

## definitions
# set $TAGS to determine, which file sets to archive
# operation to perform: CHECK, LIST, VERIFY, REMOVE, BACKUP, RETRIEVE
MODE=${MODE:-'BACKUP'} # default operation: 'BACKUP'
RMSRC=${RMSRC:-'NO'} # set to 'RMSRC' to actually perform deletion
# N.B. if retrieving files, RMSRC means files on disk are overwritten/clobbered
VERIFY=${VERIFY:-'VERIFY'} # verify tarballs; can slow down operations significantly
# N.B.: do not edit these variable; instead pass them as environment variables
DOMAINS=${DOMAINS:-'12'} # string with relevant domain indices
DATASET=${DATASET:-'FULL'} # default dataset: everything
# dataset options: FULL, DIAGS, MISC3D, DYN3D, LOGS 
# N.B.: the datasets are defined in PROCESSDATASET below
INTERVAL=${INTERVAL:-'YEARLY'} # default is yearly; used to be monthly
# data folder
INIDIR=${INIDIR:-"${PBS_O_WORKDIR}"}
DST=${DST:-"${ARCHIVE}/${INIDIR#/*/${USER}/}/"} # replicate directory tree
# replace things like '/scratch/g/group/user/' with $ARCHIVE
WRFOUT="${INIDIR}/wrfout/" # output folder
SRC=${SRC:-"${WRFOUT}"} # where the data is (on disk)

# configure file according to archiving interval
if [[ "${INTERVAL}" == "YEARLY" ]]; then
  # use this filename pattern to infer list of $TAGS
  PATTERN='-01_wrf.tgz' # filename "${TAG}${PATTERN}": remove $PATTERN, keep $TAG
  # N.B.: this option will usually only be relevant for bulk jobs; using '-01' makes sure incomplete years are not omitted
  GLOB='GLOB' # use globbing expressions in filenames
  DATEGLOB='-[01][0-9]-[0123][0-9]' # match all months (01-12) and days (1-31)
elif [[ "${INTERVAL}" == "MONTHLY" ]]; then
  # use this filename pattern to infer list of $TAGS
  PATTERN='_wrf.tgz' # filename "${TAG}${PATTERN}": remove $PATTERN, keep $TAG
  GLOB='GLOB' # use globbing expressions in filenames
  DATEGLOB='-[0123][0-9]' # match all days
elif [[ "${INTERVAL}" == "DAILY" ]]; then
  # use this filename pattern to infer list of $TAGS
  PATTERN='_wrf.tgz' # filename "${TAG}${PATTERN}": remove $PATTERN, keep $TAG
  GLOB='GLOB' # use globbing expressions in filenames
  DATEGLOB='' # actually no globbing necessary
else
  PATTERN='' # no TAG inference from file names
  DATEGLOB='' # no globbing
  GLOB='NO' # no globbing
fi # ${INTERVAL}

## function to check the contents of an HTAR archive
function CHECKHTAR () {
  local HTAR="${DST}/${1}" # archive file (absolute path on HPSS)
  local FILES=${2} # list of files that should be in the archive
  local QUIET="${3}" # suppress positive output (still print missing files!)
  local LIST=$( htar -tf "${HTAR}" | awk '{print $7}' | head -n -2 ) # column 7 are the file names, except last two lines
  local MISS=0 # missing file counter
  # evaluate globbing expression
  if [[ "${GLOB}" == 'GLOB' ]]; then
    FILES=$( ls -C ${FILES} ); fi
  # print expected archive contents
  if [[ "${QUIET}" != 'QUIET' ]]; then
    echo "${HTAR}   :::   ${FILES}"; fi # print feedback
  # loop over files in list and check presence in HTAR list
  for FILE in ${FILES}; do
    if [[ "${FILE}" != $( echo "${LIST}" | sed -n "/${FILE}/p" ) ]]; then
      if [[ ${MISS} == 0 ]]; then echo; fi # visually offset missing file list
      echo "WARNING: File ${FILE} missing in archive ${HTAR}"
      MISS=$(( ${MISS} + 1 ))
    fi
  done
  if [[ ${MISS} != 0 ]]; then echo; fi # visually offset missing file list
  # return number of missing files
  return ${MISS}
}

## function to list contents of HTAR archive
function LISTHTAR () {
  local HTAR="${DST}/${1}" # archive file (absolute path on HPSS)
  local MISS=0 # error code
  echo "${HTAR} ::: *" # print feedback
  # check if archive exists
  hsi -q ls "${HTAR}" &> /dev/null # quiet mode
  if [[ $? != 0 ]]; then
	echo "Warning: archive ${HTAR} does not exist."
	MISS=1
  else
    # list archive contents
	htar -tvf "${HTAR}" -Hcrc -Hverify=1
	MISS=$?
  fi
  # return exit code
  return ${MISS}
}

## function to verify contents of HTAR archive
function VERIFYHTAR () {
  local HTAR="${DST}/${1}" # archive file (absolute path on HPSS)
  local FILES=${2} # list of files that should be in the archive
  local QUIET="${3}" # suppress positive output (still print missing files!)
  local MISS=0 # error code
  # if globbing, just use archive table of contents
  if [[ "${GLOB}" == 'GLOB' ]]; then
    # get file list from table of contents (7th column, remove last two lines)
    FILES=$( htar -tf "${HTAR}" | awk '{print $7}' | head -n -2 ); fi
  # print expected archive contents
  if [[ "${QUIET}" != 'QUIET' ]]; then
      echo "${HTAR}   :::   ${FILES}"; fi # print feedback
  # check if archive exists
  hsi -q ls "${HTAR}" &> /dev/null # quiet mode
  if [[ $? != 0 ]]; then
	echo "Warning: archive ${HTAR} does not exist."
	MISS=1
  else
    # verify archive contents
    if [[ "${VERIFY}" == 'VERIFY' ]]; then
      # evaluate globbing expression
      if [[ "${GLOB}" == 'GLOB' ]]; then
	htar -Kvf "${HTAR}" -Hcrc -Hverify=1 # verifying all files
	MISS=$?
      else
	htar -Kvf "${HTAR}" -Hcrc -Hverify=1 ${FILES}
	MISS=$?
      fi # $GLOB
    else
      # verify without verification...
      echo "Warning: verification is switched off - checking contents instead."
      CHECKHTAR "${1}" "${2}" 'QUIET' # check contents
      MISS=$?
    fi # $VERIFY
  fi
  # return exit code
  return ${MISS}
}

## function to remove source files of an HTAR archive
function REMOVEHTAR () {
  local HTAR="${DST}/${1}" # archive file (absolute path on HPSS)
  local FILES=${2} # list of files that should be in the archive
  local LIST=$( htar -tf "${HTAR}" | awk '{print $7}' | head -n -2 ) # column 7 are the file names, except last two lines
  local MISS=0 # missing file counter
  # check files on disk
  if [[ "${GLOB}" == 'GLOB' ]]; then
    # evaluate globbing expression
    FILES=$( ls -C ${FILES} )
  else # OR
    # check if any of the files still exist
    CNT=0; for F in "${FILES}"; do
      if [[ -e "${F}" ]]; then CNT=$(( CNT + 1 )); fi; done;
  fi # $GLOB
  # print expected archive contents
  echo "${HTAR}   ---   ${FILES}" # print feedback
  if [[ -n "${CNT}" ]] && [[ ${CNT} == 0 ]]; then
    echo '   >>> none of the files exist anymore - skipping this step!'
    echo '   (use the VERIFY operation to verify integrity of the archive)'
  else
    if [[ "${VERIFY}" == 'VERIFY' ]]; then
      # verify archive contents
      VERIFYHTAR "${1}" "${2}" 'QUIET'
      MISS=$?
    fi # $VERIFY
    if [[ $MISS == 0 ]]; then
      # loop over files in list and check presence in HTAR list
      for FILE in ${FILES}; do
	if [[ "${FILE}" == $( echo "${LIST}" | sed -n "/${FILE}/p" ) ]]; then
	  if [[ "${RMSRC}" == 'RMSRC' ]]; then # additional safety check
	    if [[ -e "${FILE}" ]]; then
	      echo "   >>> removing ${FILE}"
	      rm "${FILE}"
	    else echo "   ### ${FILE} does not exist"; fi
	  else
	    echo "   >>> would remove ${FILE}, if RMSRC='RMSRC' was set..."
	  fi # RMSRC
	else
	  if [[ ${MISS} == 0 ]]; then echo; fi # visually offset missing file list
	  echo "WARNING: File ${FILE} missing in archive ${HTAR}"
	  echo "   >>> not deleting ${FILE}"
	  MISS=$(( ${MISS} + 1 ))
	fi
      done
    else
      echo
      echo "   >>>   Cannot verify integrity of archive ${HTAR} - aborting!   <<<   "
      echo
      MISS=1
    fi
  fi
  # return number of missing files
  return ${MISS}
}

## function to create a new HTAR archive
function BACKUPHTAR () {
  local HTAR="${DST}/${1}" # archive file (absolute path on HPSS)
  local FILES=${2} #
  # evaluate globbing expression
  if [[ "${GLOB}" == 'GLOB' ]]; then
    FILES=$( ls -C ${FILES} ); fi # display output in columns (i.e. long lines)
  # check if archive already exists
  echo "${FILES}   >>>   ${HTAR}" # print feedback
  hsi -q ls "${HTAR}" &> /dev/null # quiet mode
  if [[ $? == 0 ]]; then
    echo "Warning: archive ${HTAR} already exists - checking contents."
    CHECKHTAR "${1}" "${2}" 'QUIET' # check contents
    if [[ $? == 0 ]]; then
      echo "   Archive OK, skipping backup..."
      return 0
    else
      echo "   Archive contents are different - removing old archive and creating new."
      hsi -q rm "${HTAR}"
    fi
  fi
  # create archive
  htar -cpf "${HTAR}" -Hcrc -Hverify=1 ${FILES}
  # verify contents
  if [[ "${VERIFY}" == 'VERIFY' ]]; then
    # verify archive contents
    echo "Verifying contents (not sure if this is necessary, but doesn't hurt.)"
    VERIFYHTAR "${1}" "${2}" 'QUIET'
    MISS=$?
  else
    # verify without verification...
    echo "Warning: verification is switched off - checking contents instead."
    CHECKHTAR "${1}" "${2}" 'QUIET' # check contents
    MISS=$?
  fi # $VERIFY
  # return results of verification
  return $?
}

## function to create a new HTAR archive
function RETRIEVEHTAR () {
  local HTAR="${DST}/${1}" # archive file (absolute path on HPSS)
  local FILES=${2} # list of files to extract
  local MISS=0 # exit code
  # if globbing, just use archive table of contents
  if [[ "${GLOB}" == 'GLOB' ]]; then
    # get file list from table of contents (7th column, remove last two lines)
    FILES=$( htar -tf ${HTAR} | awk '{print $7}' | head -n -2 ); fi
  echo "${HTAR}   >>>   ${FILES}" # print feedback
  # check if archive exists and verify integrity (VERIFYHTAR checks existence)
  if [[ "${VERIFY}" == 'VERIFY' ]]; then
    # verify archive contents
    echo "Verifying contents."
    VERIFYHTAR "${1}" "${2}" 'QUIET'
    MISS=$?
  else
    # verify without verification...
    echo "Warning: verification is switched off - checking contents instead."
    CHECKHTAR "${1}" "${2}" 'QUIET' # check contents
    MISS=$?
  fi # $VERIFY
  if [[ $MISS != 0 ]]; then
	echo "Warning: verification of archive ${HTAR} failed - aborting!"
  else # if verified
    echo "Archive ${HTAR} exists - contents OK."
    # evaluate globbing expression
    echo
    if [[ "${RMSRC}" == 'RMSRC' ]]; then
      # check which files already exist, and report them (will get clobbered)
      NFS=''; for F in ${FILES}; do # no quotes! white space delimited list!
	if [[ -e "${F}" ]]; then NFS="${NFS} ${F}"; fi; done
      echo "Clobbering existing files: ${NFS}"
      # extract archive
      htar -xpmf "${HTAR}" -Hcrc -Hverify=1 # all files: globbing and clobbering
    else
      # check which files already exist, and skip them (don't clobber)
      NFS=''; for F in ${FILES}; do # no quotes! white space delimited list!
	if [[ ! -e "${F}" ]]; then NFS="${NFS} ${F}"; fi; done
      if [[ -n "${NFS}" ]]; then
	echo "Skipping existing files; retrieving ${NFS}"	
	htar -xpmf "${HTAR}" -Hcrc -Hverify=1 ${NFS} # extract archive
	MISS=$?
      else
	echo 'Files already exist in destination folder; run with $RMSRC=RMSRC to overwrite.'
      fi # $NFS
      echo
    fi # $CLOBBER    
  fi # if verified
  # verify contents and return result
  return ${MISS}
}

## function to back up one output dataset
# N.B.: this function is specific to the WRF output configuration; it
#       has to be redefined, to accommodate different output configurations
function PROCESSDATASET () {
  local DATE="${1}" # the current $TAG, in this context (WRF) the date...
  local ERR=0 # error counter
  ## define datasets
  DATENAME="${DATE}" # used in archive file names etc.  
  # use globbing expression if asked
  if [[ "${GLOB}" == 'GLOB' ]]; 
    then DATESTR="${DATE}${DATEGLOB}"
    else DATESTR="${DATE}"  # used in output data file names
  fi # GLOB
  unset DIAGS MISC_D1 DYN_D1 MISC_D2 DYN_D2 MISC_D3 DYN_D3 STATIC LOGS
  # special case, if TAG/DATE is FINAL
  if [[ "${DATE}" == 'FINAL_ALL' ]] &&  [[ "${GLOB}" == 'GLOB' ]]; then # all domains, all time steps
    local FINAL="static.tgz wrfconst_d??.nc wrfrst_d??_* *_pyWPS.tgz *_real.tgz *_wrf.tgz *_logs.tgz" # put configuration files, all logs, and restart files into one archive
  elif [[ "${DATE}" == 'FINAL' ]] &&  [[ "${GLOB}" == 'GLOB' ]]; then # all domains, only last time step
    local FINAL="static.tgz *_pyWPS.tgz *_real.tgz *_wrf.tgz *_logs.tgz" # put configuration files, all logs, and restart files into one archive
    for D in $( echo "${DOMAINS}" | fold --width=1 ); do
      LSTRST=$( ls wrfrst_d0${D}_* | tail -n 1 ) # last restart for every domain
      FINAL="${FINAL} wrfconst_d0${D}.nc ${LSTRST}"
    done # $DOMAINS
  else
    # logs and static data
    if [[ "${DATASET}" == 'LOGS' ]] || [[ "${DATASET}" == 'DIAGS' ]] || [[ "${DATASET}" == 'FULL' ]]; then
      local STATIC="static.tgz" # only on cold start, otherwise skip
      for D in $( echo "${DOMAINS}" | fold --width=1 )
	do STATIC="${STATIC} wrfconst_d0${D}.nc"
      done # $DOMAINS
      local LOGS="${DATESTR}_pyWPS.tgz ${DATESTR}_real.tgz ${DATESTR}_wrf.tgz ${DATENHAME}_logs.tgz"
    # only smaller diagnostics (all domains in one file)
    fi; if [[ "${DATASET}" == 'DIAGS' ]] || [[ "${DATASET}" == 'FULL' ]]; then      
      local DIAGS='' # construct file list using a loop over domain indicies
      for D in $( echo "${DOMAINS}" | fold --width=1 )
	do DIAGS="${DIAGS} wrfxtrm_d0${D}_${DATESTR}_00:00:00.nc wrfsrfc_d0${D}_${DATESTR}_00:00:00.nc wrfplev3d_d0${D}_${DATESTR}_00:00:00.nc"
      done # $DOMAINS
    # misc 3D fields (one file per domain)
    fi; if [[ "${DATASET}" == 'MISC3D' ]] || [[ "${DATASET}" == 'FULL' ]]; then
      local MISC_D1="wrfmoist3d_d01_${DATESTR}_00:00:00.nc wrflsm_d01_${DATESTR}_00:00:00.nc wrfrad_d01_${DATESTR}_00:00:00.nc wrffdda_d01_${DATESTR}_00:00:00.nc wrfhydro_d01_${DATESTR}_00:00:00.nc"
      local MISC_D2="wrfmoist3d_d02_${DATESTR}_00:00:00.nc wrflsm_d02_${DATESTR}_00:00:00.nc wrfrad_d02_${DATESTR}_00:00:00.nc wrfhydro_d01_${DATESTR}_00:00:00.nc"
      local MISC_D3="wrfmoist3d_d03_${DATESTR}_00:00:00.nc wrflsm_d03_${DATESTR}_00:00:00.nc wrfrad_d03_${DATESTR}_00:00:00.nc wrfhydro_d03_${DATESTR}_00:00:00.nc"
      local MISC_D4="wrfmoist3d_d04_${DATESTR}_00:00:00.nc wrflsm_d04_${DATESTR}_00:00:00.nc wrfrad_d04_${DATESTR}_00:00:00.nc wrfhydro_d04_${DATESTR}_00:00:00.nc"
    # 3D dry dynamics (one file per domain)
    fi; if [[ "${DATASET}" == 'DYN3D' ]] || [[ "${DATASET}" == 'MISC3D' ]] || [[ "${DATASET}" == 'FULL' ]]; then
      local DYN_D1="wrfdrydyn3d_d01_${DATESTR}_00:00:00.nc"
      local DYN_D2="wrfdrydyn3d_d02_${DATESTR}_00:00:00.nc"
      local DYN_D3="wrfdrydyn3d_d03_${DATESTR}_00:00:00.nc"
      local DYN_D4="wrfdrydyn3d_d04_${DATESTR}_00:00:00.nc"
    fi 
    # return error if dataset not found
    if [[ "${DATASET}" != 'DYN3D' ]] && [[ "${DATASET}" != 'MISC3D' ]] && [[ "${DATASET}" != 'FULL' ]] && [[ "${DATASET}" != 'LOGS' ]] && [[ "${DATASET}" != 'DIAGS' ]]; then
      echo
      echo "   >>>   WARNING: dataset ${DATASET} not found! (aborting)   <<<   "
      echo
      return 1
    fi # $DATASET
  fi # if TAG=FINAL
  # determine if this is a cold start or a restart (check for restart files)
  ls "${SRC}/wrfrst_d??_${DATESTR}_00:00:00" >& /dev/null # this also works with globbing expressions
  if [[ $? == 0  ]]; then
    # restart run: backup restart file
    if [[ -n "${MISC_D1}" ]]; then MISC_D1="${MISC_D1} wrfrst_d01_${DATESTR}_00:00:00"; fi
    if [[ -n "${MISC_D2}" ]]; then MISC_D2="${MISC_D2} wrfrst_d02_${DATESTR}_00:00:00"; fi
    if [[ -n "${MISC_D3}" ]]; then MISC_D3="${MISC_D3} wrfrst_d03_${DATESTR}_00:00:00"; fi
    if [[ -n "${MISC_D4}" ]]; then MISC_D4="${MISC_D4} wrfrst_d04_${DATESTR}_00:00:00"; fi
    if [[ "${GLOB}" != 'GLOB' ]]; then
      unset STATIC; fi # skip this step, if no globbing is used
    # cold start: backup data tables, constants, and geogrid files
  fi
  echo
  # operation feedback
  echo "   ***   ${MODE} ${DATENAME}   ***   "
  # delete source or not?
  if [[ ${RMSRC} == 'RMSRC' ]]
    then if [[ ${MODE} == 'RETRIEVE' ]]
	then echo "  (Overwriting source files!) "
	else echo " ++  Removing source files!  ++ "
      fi # $MODE
    else echo " (leaving source files untouched)   "
  fi # $RMSRC
  echo
  ## process file lists (skip empty ones)
  if [[ -n "${FINAL}" ]]; then
    # only executed at the end of an experiment
    echo '  Static data, logs, and WRF restart files (all domains):'
    "${MODE}HTAR" "wrffinal.tar" "${FINAL}"
    ERR=$(( ${ERR} + $? ))
  fi; if [[ -n "${STATIC}" ]]; then
    # only execute this for the first step/date (cold start)
    echo '  Static data, WRF constants, and geogrid files (both domains):'
    "${MODE}HTAR" "wrfstatic.tar" "${STATIC}"
    ERR=$(( ${ERR} + $? ))
  fi; if [[ -n "${DIAGS}" ]] || [[ -n "${LOGS}" ]]; then
	echo '  Pressure level and surface fields, log files (both domains):' # short description of archive
	"${MODE}HTAR" "wrfdiags_${DATENAME}.tar" "${DIAGS} ${LOGS}"
	ERR=$(( ${ERR} + $? )) # CHECKHTAR returns the number of missing files as exit code
  fi; if [[ -n "${MISC_D1}" ]] && [[ "${DOMAINS}" == *1* ]]; then
	echo '  Miscellaneous field, including 3D moisture (1st domain):'
	"${MODE}HTAR" "wrfmisc_d01_${DATENAME}.tar" "${MISC_D1}"
	ERR=$(( ${ERR} + $? ))
  fi; if [[ -n "${MISC_D2}" ]] && [[ "${DOMAINS}" == *2* ]]; then
	echo '  Miscellaneous field, including 3D moisture (2nd domain):'
	"${MODE}HTAR" "wrfmisc_d02_${DATENAME}.tar" "${MISC_D2}"
	ERR=$(( ${ERR} + $? ))
  fi; if [[ -n "${MISC_D3}" ]] && [[ "${DOMAINS}" == *3* ]]; then
	echo '  Miscellaneous field, including 3D moisture (3rd domain):'
	"${MODE}HTAR" "wrfmisc_d03_${DATENAME}.tar" "${MISC_D3}"
	ERR=$(( ${ERR} + $? ))
  fi; if [[ -n "${MISC_D4}" ]] && [[ "${DOMAINS}" == *4* ]]; then
	echo '  Miscellaneous field, including 3D moisture (4th domain):'
	"${MODE}HTAR" "wrfmisc_d04_${DATENAME}.tar" "${MISC_D4}"
	ERR=$(( ${ERR} + $? ))
  fi; if [[ -n "${DYN_D1}" ]] && [[ "${DOMAINS}" == *1* ]]; then
	echo '  3D dry dynamics fields (1st domain):'
	"${MODE}HTAR" "wrfdrydyn_d01_${DATENAME}.tar" "${DYN_D1}"
	ERR=$(( ${ERR} + $? ))
  fi; if [[ -n "${DYN_D2}" ]] && [[ "${DOMAINS}" == *2* ]]; then
	echo '  3D dry dynamics fields (2nd domain):'
	"${MODE}HTAR" "wrfdrydyn_d02_${DATENAME}.tar" "${DYN_D2}"
	ERR=$(( ${ERR} + $? ))
  fi; if [[ -n "${DYN_D3}" ]] && [[ "${DOMAINS}" == *3* ]]; then
	echo '  3D dry dynamics fields (3rd domain):'
	"${MODE}HTAR" "wrfdrydyn_d03_${DATENAME}.tar" "${DYN_D3}"
	ERR=$(( ${ERR} + $? ))
  fi; if [[ -n "${DYN_D4}" ]] && [[ "${DOMAINS}" == *4* ]]; then
	echo '  3D dry dynamics fields (4th domain):'
	"${MODE}HTAR" "wrfdrydyn_d04_${DATENAME}.tar" "${DYN_D4}"
	ERR=$(( ${ERR} + $? ))
  fi
  # check for errors
  if [[ ${ERR} != 0 ]]; then
    echo "   >>>   WARNING: there were ${ERR} errors!   <<<   "
    return 1
  else
    echo "${MODE} ${DATENAME} OK!"
    return 0
  fi
}

## execution

# set up directories
hsi mkdir -p "${DST}"
cd "${SRC}"

# feedback
echo
echo
echo '   Settings'
echo "Operation to perform:       MODE = ${MODE}"
echo "Delete source files?       RMSRC = ${RMSRC}"
echo "Verify archive integrity? VERIFY = ${VERIFY}"
echo "Use globbing expressions:   GLOB = ${GLOB}"
echo '   Dataset'
echo "File set to work on:     DATASET = ${DATASET}"
echo "Domains to include:      DOMAINS = ${DOMAINS}"
echo "Archiving interval:     INTERVAL = ${INTERVAL}"
echo '   Data Folders'
echo 'Archive folder:'
echo "  DST = ${DST}"
echo 'Source (disk) folder:'
echo "  SRC = ${SRC}"
echo
echo

# if no TAGS are given, use file pattern to guess
if [[ -z "${TAGS}" ]] && [[ -n "${PATTERN}" ]]; then
  echo "Inferring TAGS from pattern: PATTERN=${PATTERN}"
  for T in $( ls *${PATTERN} ); do
    TAGS="${TAGS} ${T%${PATTERN}}"; done # extract $TAG from filename
  echo "TAGS=${TAGS}"
else
  echo "TAGS provided by caller:"
  echo "TAGS=${TAGS}"
fi # if no $TAGS
echo
echo

# set counter
ERRORS=0
OPERATIONS=0
# cycle over monthly output datasets
for TAG in ${TAGS} # use WRF log-files as indicator
do
  time -p PROCESSDATASET ${TAG}
  if [ $? == 0 ]; then OPERATIONS=$(( ${OPERATIONS} + 1 ))
  else ERRORS=$(( ${ERRORS} + 1 )); fi
  echo
  echo '   ==========================================================================   '
  echo
done
hsi -q ls "${DST}"

trap - TERM INT

echo
if [ ${ERRORS} == 0 ]; then
  echo "   <<<   ALL ${OPERATIONS} OPERATIONS OK   >>>   "
  echo
  exit 0
else
  echo "   >>>   WARNING: ${ERRORS} OPERATIONS FAILD OR INCOMPLETE!   <<<   "
  echo "   >>>                 ${OPERATIONS} OPERATIONS OK             <<<   "
  echo
  # /scinet/gpc/bin/exit2msg ${ERRORS} # translate exit codes to human-readable messages
  exit ${ERRORS}
fi
